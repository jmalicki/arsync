searchState.loadedDescShard("arsync", 0, "arsync: High-performance file copying using <code>io_uring</code>\nA compio-compatible async semaphore for bounding ‚Ä¶\nAcquire a permit, waiting asynchronously if none are ‚Ä¶\nAdaptive concurrency control with file descriptor awareness\nAdd permits back to the semaphore (for adaptive ‚Ä¶\nGet the number of available permits\nCommand-line interface definitions\nFile copying operations using <code>io_uring</code>\nTrait-based file copying\nDirectory traversal and copying functionality\nError handling and types\nWrapper around compio::fs::File that implements AsyncFile ‚Ä¶\nReturns the argument unchanged.\nHardlink tracking for race-free hardlink synchronization\nInternationalization (i18n) support for arsync using Fluent\nGet the number of permits currently in use (max - ‚Ä¶\nCalls <code>U::from(self)</code>.\n<code>io_uring</code> integration module\nGet the maximum number of permits (configured limit)\nMetadata preservation configuration and operations\nCreate a new semaphore with the given number of permits\nProgress tracking and reporting\nRemote synchronization protocol foundation\nReduce the number of available permits (for adaptive ‚Ä¶\nStatistics tracking for file synchronization operations\nMain synchronization logic\nConvenience macro for translating messages\nCore traits for filesystem abstraction\nTry to acquire a permit without waiting\nAdaptive concurrency controller that responds to resource ‚Ä¶\nConcurrency control configuration options\nStatistics about concurrency control\nType alias for a shared semaphore wrapped in <code>Arc</code>\nAcquire a permit\nAdapt to file descriptor exhaustion by reducing concurrency\nCurrently available permits\nCheck system file descriptor limits and warn if too low\nCounter for EMFILE errors\nNumber of EMFILE errors encountered\nFlag indicating if we‚Äôve already warned about FD ‚Ä¶\nCheck if should fail on exhaustion\nIf true, fail immediately on resource exhaustion; if ‚Ä¶\nWhether to fail hard on exhaustion (true = fail, false = ‚Ä¶\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nHandle an error, checking if it‚Äôs EMFILE and adapting or ‚Ä¶\nPermits currently in use\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nDetect if an I/O error is EMFILE (file descriptor ‚Ä¶\nCheck if an error is EMFILE (too many open files)\nGet the maximum files in flight\nMaximum number of concurrent operations (guaranteed &gt;= 1)\nMaximum permits configured\nGet the minimum permits (floor for adaptive reduction)\nMinimum permits to maintain when adapting (never go below ‚Ä¶\nMinimum permits to maintain\nCreate new concurrency options with validation\nCreate a new adaptive controller from options\nThe underlying semaphore\nGet current statistics\nHigh-performance bulk file copying utility using <code>io_uring</code>\nAutomatically choose the best method\nConcurrency control configuration\nUse <code>copy_file_range</code> for same-filesystem copies\nI/O and <code>FileOperations</code> configuration\nOutput and logging configuration\nParallel copy configuration for large files\nPaths configuration\nUse traditional read/write operations\nUse splice for zero-copy operations\nGet buffer size in bytes (returns None if auto-detect)\nBuffer size in KB (default: auto-detect ‚Üí 64KB)\nGet chunk size in bytes\nChunk size (in MB) for each read/write operation in ‚Ä¶\nConcurrency control configuration\nGet copy method (convenience method for backwards ‚Ä¶\nCopy method to use\nNumber of CPU cores to use (0 = auto-detect)\nGet destination path (convenience method for backwards ‚Ä¶\nDestination directory or file\nShow what would be copied without actually copying\nGet the actual buffer size in bytes (handles None ‚Üí ‚Ä¶\nGet the actual CPU count to use\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\n<code>FileOperations</code> configuration (<code>io_uring</code>, buffers)\nCheck if the source is a directory\nCheck if the source is a single file\nMaximum recursion depth for parallel file copying\nGet max files in flight (convenience method for backwards ‚Ä¶\nMaximum total files in flight (across all CPU cores)\nMetadata preservation flags (used by copy operations)\nGet minimum file size in bytes\nMinimum file size (in MB) to trigger parallel copying\nDisable adaptive concurrency control (fail fast on ‚Ä¶\nOutput and logging configuration\nParallel copy configuration\nSource and destination paths\nEnable pirate speak (arrr! üè¥‚Äç‚ò†Ô∏è)\nShow progress information\nGet queue depth (convenience method for backwards ‚Ä¶\nQueue depth for <code>io_uring</code> operations\nCheck if quiet mode is enabled (convenience method for ‚Ä¶\nQuiet mode (suppress all output except errors)\nCheck if hard links should be preserved (delegates to ‚Ä¶\nCheck if symlinks should be preserved (delegates to ‚Ä¶\nCheck if ownership should be preserved (delegates to ‚Ä¶\nCheck if permissions should be preserved (delegates to ‚Ä¶\nCheck if timestamps should be preserved (delegates to ‚Ä¶\nCheck if xattrs should be preserved (delegates to metadata ‚Ä¶\nCheck if recursive copying should be performed (delegates ‚Ä¶\nDetermine if a file should be copied in parallel\nGet source path (convenience method for backwards ‚Ä¶\nSource directory or file\nConvert to the options struct used by ‚Ä¶\nValidate command-line arguments\nValidate parallel copy configuration\nCheck if verbose mode is enabled (convenience method for ‚Ä¶\nVerbose output (-v, -vv, -vvv)\nDefault I/O buffer size (in bytes) used for chunked ‚Ä¶\nGlobal static dispatcher for parallel copy operations.\n2MB huge page size for alignment in parallel copies\nAlign offset to page boundary (round down)\nCopy a single file (public API)\nInternal: Copy a single file with optimized, TOCTOU-safe ‚Ä¶\nCopy file using compio read/write operations\nCopy a file using parallel recursive binary splitting\nCopy a region sequentially\nDefault buffer size for trait-based copying\nCopy a file using the AsyncFile trait\nDirectory copy operation statistics\nLocation information for a file/directory with <code>DirectoryFd</code> ‚Ä¶\nContext passed through directory traversal operations\nTotal number of bytes copied\nAdaptive concurrency controller (prevents FD exhaustion)\nCopy an entire directory tree from source to destination\nCopy method to use (e.g., auto, <code>copy_file_range</code>, splice)\nTotal number of directories created\nGlobal dispatcher for parallel operations\nNumber of errors encountered\nFile operations handler (contains copy method)\nFilename relative to <code>parent_dir</code> (basename only, no path ‚Ä¶\nTotal number of files copied\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nHardlink tracker for inode-based deduplication\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nDirectory and file metadata preservation operations\nMetadata preservation configuration\nCreate FileMetadata from path (fallback - path-based, ‚Ä¶\nParallel copy configuration\nParent directory as <code>DirectoryFd</code> (for TOCTOU-safe ‚Ä¶\nFull path (used only for error messages and logging)\nPreserve directory metadata (legacy path-based wrapper)\nPreserve directory metadata using pre-opened <code>DirectoryFd</code> ‚Ä¶\nPreserve directory extended attributes from source to ‚Ä¶\nShared statistics accumulator\nSymlink copying and metadata preservation\nNumber of symlinks processed\nDirectory traversal and recursive processing\nCore types for directory traversal and copying\nPreserve directory metadata (legacy path-based wrapper)\nPreserve directory metadata using pre-opened <code>DirectoryFd</code> ‚Ä¶\nPreserve directory extended attributes from source to ‚Ä¶\nPreserve file metadata (permissions, ownership, timestamps)\nCopy a symlink preserving its target and metadata\nProcess a symlink by copying it\nHandle creation of a hardlink when the inode has already ‚Ä¶\nProcess directory entry using compio‚Äôs dispatcher for ‚Ä¶\nInternal: Process directory entry recursively with ‚Ä¶\nProcess a regular file during directory traversal.\nProcess root entry (wrapper that sets up <code>DirectoryFd</code> for ‚Ä¶\nDirectory traversal using compio‚Äôs dispatcher for ‚Ä¶\nDirectory copy operation statistics\nLocation information for a file/directory with <code>DirectoryFd</code> ‚Ä¶\nContext passed through directory traversal operations\nTotal number of bytes copied\nAdaptive concurrency controller (prevents FD exhaustion)\nCopy method to use (e.g., auto, <code>copy_file_range</code>, splice)\nTotal number of directories created\nGlobal dispatcher for parallel operations\nNumber of errors encountered\nFile operations handler (contains copy method)\nFilename relative to <code>parent_dir</code> (basename only, no path ‚Ä¶\nTotal number of files copied\nHardlink tracker for inode-based deduplication\nMetadata preservation configuration\nCreate FileMetadata from path (fallback - path-based, ‚Ä¶\nParallel copy configuration\nParent directory as <code>DirectoryFd</code> (for TOCTOU-safe ‚Ä¶\nFull path (used only for error messages and logging)\nShared statistics accumulator\nNumber of symlinks processed\nFile copy operation failed\nDirectory traversal failed\nContains the error value\nError from compio-fs-extended\nFile descriptor exhaustion (EMFILE)\nGeneral filesystem error\nInternal application error\nInvalid configuration error\nStandard I/O error\n<code>io_uring</code> specific error\nMetadata operation failed\nContains the success value\nPermission denied error\nSynchronization and file operation errors\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nWrapper around compio::fs::File that implements AsyncFile ‚Ä¶\nThe underlying compio file\nReturns the argument unchanged.\nGet a reference to the underlying file\nCalls <code>U::from(self)</code>.\nConsume the wrapper and return the underlying file\nCreate a new wrapper around a compio file\nStatistics about hardlink tracking\nFilesystem boundary and hardlink tracker\nHardlink tracking information with concurrent ‚Ä¶\nInode information used as a key for hardlink tracking\nCheck if inode is on source filesystem using a predicate\nCondition variable signaled when copy completes Linker ‚Ä¶\nDevice ID\nDestination path (set at registration time by first copier)\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet the destination path for an inode\nGet all hardlink groups that have multiple links\nGet the original path for an inode if it‚Äôs been ‚Ä¶\nGet statistics about the filesystem tracking\nNumber of inodes with multiple hardlinks\nTracked hardlinks by inode\nInode number\nInode number (immutable after creation)\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCheck if an inode has been copied\nCheck if a device is on the source filesystem\nCheck if a path is on the source filesystem\nCheck if a device is on the same filesystem as the source\nNumber of hardlinks found (incremented atomically)\nCreate a new filesystem tracker\nOriginal file path (immutable after creation)\nRegister a file for hardlink tracking (async - waits if ‚Ä¶\nSet the source filesystem device ID\nSignal that an inode‚Äôs copy is complete\nSource filesystem device ID (set during scan to avoid ‚Ä¶\nTotal number of tracked inodes\nTotal number of hardlink references\nCreate a tracker with a known source filesystem\nCurrent active locale (thread-safe)\nSupported language identifiers\nEnglish (US) fluent resource\nPirate language identifier (using qaa - reserved for ‚Ä¶\nErrors that can occur during internationalization ‚Ä¶\nSupported languages/locales\nThe locale lock is poisoned (another thread panicked while ‚Ä¶\nFailed to acquire the locale lock\nTranslation key enum - maps to Fluent message IDs\nPirate fluent resource\nCreate a fluent bundle for the given locale (creates fresh ‚Ä¶\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet the translated string for this key in the current ‚Ä¶\nGet the appropriate FTL string for a locale\nGet the current language\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nGet the BCP 47 locale identifier for this language\nGet the Fluent message ID for this key\nSet the current language for all translations\nGet the translated string for this key in a specific ‚Ä¶\nCopy operation completed successfully\nFile copy operation with progress tracking\nStatus of a file copy operation\nCopy operation failed with error message\nComprehensive file metadata for preservation\nBasic file operations using async I/O\nCopy operation is currently in progress\nCopy operation is pending\nLast access timestamp\nBuffer size for I/O operations in bytes\nNumber of bytes copied so far\nCopy file content using file descriptors with compio ‚Ä¶\nCopy file using chunked read/write with compio buffer ‚Ä¶\nCopy file with full metadata preservation using file ‚Ä¶\nCreate directory\nDestination file path\nCheck if file exists\nTotal file size in bytes\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet comprehensive file metadata asynchronously\nGet file size\nGroup ID of the file owner\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nMark the copy operation as failed\nLast modification timestamp\nCreate a new copy operation\nCreate new file operations instance\nFile permissions (mode bits including special permissions)\nGet the progress percentage of the copy operation\nFile size in bytes\nSource file path\nCurrent copy status\nUser ID of the file owner\nUpdate the progress of the copy operation\nMetadata preservation configuration\nPreserve ACLs (implies ‚Äìperms)\nArchive mode; same as -rlptgoD (recursive, links, perms, ‚Ä¶\nPreserve access (use) times\nPreserve creation times (when supported)\nPreserve device files (super-user only) and special files\nReturns the argument unchanged.\nSync each file to disk after writing (like rsync ‚Äìfsync)\nGet precise timestamps from a file path\nPreserve group\nPreserve hard links\nCalls <code>U::from(self)</code>.\nCopy symlinks as symlinks\nPreserve owner (super-user only)\nPreserve permissions\nPreserve POSIX ACLs (deprecated: use -A/‚Äìacls)\nPreserve all file metadata from source to destination file ‚Ä¶\nPreserve file ownership using file descriptors\nPreserve only file permissions from source to destination\nPreserve timestamps with nanosecond precision using FD\nPreserve extended attributes (deprecated: use -X/‚Äìxattrs)\nPreserve file extended attributes using file descriptors\nRecurse into directories\nCheck if hard links should be preserved\nCheck if symlinks should be copied as symlinks\nCheck if ownership (user and/or group) should be preserved\nCheck if permissions should be preserved\nCheck if timestamps should be preserved\nCheck if extended attributes should be preserved\nCheck if recursive copying should be performed\nPreserve modification times\nPreserve extended attributes\nProgress statistics for synchronization operations\nProgress tracker for file synchronization operations\nRunning total of bytes successfully copied\nTotal number of bytes successfully copied during the ‚Ä¶\nTotal number of bytes discovered during traversal (via ‚Ä¶\nTime elapsed since the operation started\nRunning count of files successfully processed/copied\nNumber of files successfully processed during the operation\nTotal number of files discovered during traversal (via ‚Ä¶\nMark the progress tracking operation as complete\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a new progress tracker instance\nVisual progress bar for user feedback\nSet the total number of bytes to be processed\nGet current progress statistics\nTrack a file discovered during traversal (via statx)\nTrack progress for a specific copy operation\nUpdate progress with additional bytes copied\nLocal filesystem path\nParsed location (local or remote)\nRole in pipe-based protocol testing\nReceive data (like rsync server)\nRemote path accessed via SSH\nSend data (like rsync client)\nChecksum algorithms for rsync delta transfer\nReturns the argument unchanged.\nReturns the argument unchanged.\nrsync Protocol Handshake Implementation\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCheck if this is a local location\nCheck if this is a remote location\nParse rsync-style path: <code>[user@]host:path</code> or <code>/local/path</code>\nGet the path component\nPipe-based transport for rsync protocol testing\nrsync wire protocol implementation\nrsync Wire Protocol Compatibility Layer\nSSH connection management for remote sync\nGeneric transport abstraction for rsync protocol\nVariable-length integer encoding (varint)\nRemote hostname or IP address\nRemote filesystem path\nRemote username (None = current user)\nRolling checksum modulus (prime number for Adler-32)\nCompute rolling checksum (Adler-32 style)\nIncrementally update rolling checksum when sliding window\nCompute rolling checksum with seed (rsync protocol)\nCompute strong checksum (MD5)\nNegotiated effective capabilities\nRandom seed for checksum algorithms\nHandshake complete - ready for file transfer\nReceived remote capability flags\nSent our capability flags to remote\nState machine for protocol handshake\nInitial state - handshake not started\nMaximum protocol version we understand\nMinimum protocol version we can negotiate with\nCurrent protocol version supported by arsync\nNegotiated protocol capabilities\nThis side is receiving files\nRole in the protocol handshake\nExchanging checksum seeds (optional phase)\nThis side is sending files\nNegotiated effective protocol version\nReceived remote protocol version\nSent our protocol version to remote\nPOSIX ACLs are preserved\nFile uses checksums (weak + strong) for delta algorithm\nUse random seed for checksums (security)\nDevice files and special files are preserved\nHard links are preserved\nFile permissions are preserved\nSparse file optimization (holes not transferred)\nSymbolic links are preserved\nFile timestamps are preserved\nExtended attributes are preserved\nAdvance the handshake state machine\nOptional checksum seed (if <code>XMIT_CHECKSUM_SEED</code> is set)\nCapability flags (intersection of both sides)\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreate a seed from raw bytes (little-endian)\nGenerate a new random checksum seed\nGet capabilities if handshake is complete\nGet our supported capabilities\nGet checksum seed if handshake is complete and seed was ‚Ä¶\nPerform handshake with specified role\nPerform handshake as receiver\nPerform handshake as sender\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCheck if handshake is complete\nCheck if this is the receiver role\nCheck if this is the sender role\nCheck if the seed is zero (uninitialized)\nNegotiate capabilities between client and server\nCreate new capabilities with default flags\nGet the opposite role\nThe random seed value\nCheck if POSIX ACLs are supported\nCheck if checksum seed is supported\nCheck if checksums are supported\nCheck if device files are supported\nCheck if hard links are supported\nCheck if file permissions are supported\nCheck if sparse file optimization is supported\nCheck if symbolic links are supported\nCheck if timestamps are supported\nCheck if extended attributes are supported\nConvert seed to bytes (little-endian)\nNegotiated protocol version (minimum of both sides)\nNegotiated capabilities\nCapabilities with seed exchange in progress\nFinal negotiated capabilities\nOur capability flags\nOur capability flags\nOur protocol version\nOur protocol version\nEffective protocol version (minimum of both)\nEffective protocol version\nEffective protocol version\nRemote capability flags\nRemote protocol version\nChecksum seed (if negotiated)\nPipe-based transport for rsync protocol\nCreate a Unix pipe pair, returns (<code>read_fd</code>, <code>write_fd</code>)\nReturns the argument unchanged.\nCreate from specific file descriptors\nCreate from stdin/stdout (for ‚Äìpipe mode)\nCalls <code>U::from(self)</code>.\nTransport name for debugging\nReader end (stdin or custom FD)\nWriter end (stdout or custom FD)\nBlock checksum for rsync delta algorithm\nCopy from basis file using block index\nDefault block size for checksums (rsync default)\nDelta instruction for reconstructing files\nFile list entry in rsync protocol\nRaw data to insert (when no match found)\nMinimum block size\nMinimum protocol version we accept\nProtocol version we support\nRolling checksum constants (Adler-32 style)\nApply delta to reconstruct file (receiver side)\nApply full metadata to a file\nIndex of this block\nCalculate optimal block size for a file\nCount literal and matched bytes in delta\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGenerate block checksums for a file (receiver side)\nGenerate delta by finding matching blocks (sender side)\nGenerate file list for transmission (old stub, kept for ‚Ä¶\nGenerate simple file list (minimal implementation)\nGroup ID\nrsync protocol handshake (old stub, kept for reference)\nHandshake as receiver\nHandshake as sender\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nWhether this is a symbolic link\nFile mode (permissions and file type bits)\nModification time (Unix timestamp)\nOffset in file where this block starts\nRelative path from source root\nPull files from remote using rsync protocol over SSH\nPush files to remote using rsync protocol over SSH\nReceive block checksums from transport\nReceive delta instructions from transport\nReceive file list from connection (old stub, kept for ‚Ä¶\nReceive file list (with full metadata)\nReceive files via pipe transport (for testing)\nSend block checksums over transport\nSend delta instructions over transport\nSend file list over connection (old stub, kept for ‚Ä¶\nSend file list (with full metadata)\nSend files via pipe transport (for testing)\nFile size in bytes\nMD5 checksum (slow, collision-resistant)\nSymlink target path (if is_symlink is true)\nUser ID (owner)\nRolling checksum (fast, collision-prone)\nIndex of the matching block in the basis file\nLength of the match in bytes\nrsync protocol uses multiplexed I/O with tags Tag values ‚Ä¶\nMessage tags (rsync protocol)\nBidirectional multiplex wrapper (can both read and write)\nrsync multiplexed message\nMultiplexed reader with buffering\nMultiplexed writer\nBlock checksum in rsync wire format\nInternal buffer for message reassembly (currently unused - ‚Ä¶\nCurrent position in buffer (currently unused)\nMessage payload bytes\nDecode a single file entry from bytes\nDecode file list from rsync wire format\nDecode varint from synchronous reader (for use with Cursor)\nConvert delta instructions to rsync token stream\nEncode file list in rsync wire format (simplified - no ‚Ä¶\nExpect a specific message tag\nrsync file list flags (from flist.c)\nFlush underlying transport\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nParse message tag from wire format byte\nGenerate file list (reuse from rsync.rs)\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a new multiplexed reader wrapping a transport\nCreate a new multiplexed writer wrapping a transport\nCreate a new bidirectional multiplex wrapper\nInternal buffer for message reassembly (currently unused)\nCurrent position in read buffer (currently unused)\nRead a data message, handling multiplexed protocol\nRead data message, skipping INFO/LOG messages\nRead next multiplexed message\nRead a multiplexed message\nRead a multiplexed message from rsync protocol stream\nRead multiple messages until end marker\nReceive block checksums in rsync wire format\nReceive delta in rsync token format\nReceive files from rsync sender (file list only - minimal ‚Ä¶\nSend files to rsync receiver (file list only - minimal ‚Ä¶\nSend block checksums in rsync wire format\nSend delta in rsync token format\nStrong checksum (MD5 or MD4, variable length: 2 or 16 ‚Ä¶\nMessage type tag (Data, Info, Error, etc.)\nParse rsync token stream back to delta instructions\nUnderlying transport for reading wire protocol messages\nUnderlying transport for writing tagged messages\nUnderlying transport for bidirectional message passing\nGet mutable reference to underlying transport\nGet mutable reference to underlying transport\nRolling checksum (32-bit, fast but collision-prone)\nWrite data with multiplexed protocol\nWrite data message\nWrite error message\nWrite info message\nWrite a tagged message\nWrite a multiplexed message\nWrite a multiplexed message to rsync protocol stream\nExtended flags follow this byte\nFilename is longer than 255 bytes\nGID unchanged from previous file (delta encoding)\nMode unchanged from previous file (delta encoding)\nName matches previous file (hardlink)\nUID unchanged from previous file (delta encoding)\nTop-level directory flag\nSSH connection to remote host\nConnect to remote host via SSH\nReturns the argument unchanged.\nRemote host\nCalls <code>U::from(self)</code>.\nSSH process\nStart remote server (send initial protocol negotiation)\nstdin pipe to remote arsync\nstdout pipe from remote arsync\nRemote user\nGeneric transport for rsync protocol\nGet transport name for debugging\nHelper to read exact number of bytes\nCheck if transport supports multiplexing (multiple ‚Ä¶\nHelper to write all bytes\nDecode a varint from transport\nDecode signed varint (zigzag decoding)\nEncode a u64 as varint (7-bit continuation encoding)\nEncode varint into an existing buffer (more efficient)\nEncode i64 as signed varint (zigzag encoding)\nStatistics tracking with interior mutability via atomics\nGet the number of bytes copied (lock-free atomic read)\nBytes copied counter using atomics\nGet the number of directories created (lock-free atomic ‚Ä¶\nDirectories created counter using atomics\nGet the number of errors encountered (lock-free atomic ‚Ä¶\nErrors counter using atomics\nGet the number of files copied (lock-free atomic read)\nFiles copied counter using atomics for lock-free operations\nReturns the argument unchanged.\nIncrement the number of bytes copied by a given amount ‚Ä¶\nIncrement the number of directories created (lock-free ‚Ä¶\nIncrement the error counter (lock-free atomic operation)\nIncrement the number of files copied (lock-free atomic ‚Ä¶\nIncrement the number of symlinks processed (lock-free ‚Ä¶\nCalls <code>U::from(self)</code>.\nConvert atomic statistics back to <code>DirectoryStats</code>\nCreate a new <code>SharedStats</code> with atomic counters\nGet the number of symlinks processed (lock-free atomic ‚Ä¶\nSymlinks processed counter using atomics\nStatistics for a synchronization operation\nTotal number of bytes copied during the operation\nTotal duration of the synchronization operation\nNumber of files successfully copied during the operation\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nMain synchronization function\nAsyncDirectory and AsyncDirectoryEntry traits for unified ‚Ä¶\nAsyncFile trait for unified file operations\nAsyncMetadata trait for unified metadata operations\nUnified directory interface for both local and remote ‚Ä¶\nUnified directory entry interface for both local and ‚Ä¶\nThe directory entry type\nThe metadata type for this entry\nThe metadata type for this directory\nCheck if this entry is a directory\nCheck if this entry is a file\nCheck if this entry is a symlink\nGet metadata for this entry\nGet metadata for this directory\nGet the entry name (basename only, no path separators)\nGet the full path to this entry\nRead all entries in the directory\nUnified file interface for both local and remote operations\nThe metadata type for this file\nCopy data from this file to another file using ‚Ä¶\nGet file metadata\nRead data from the file at a specific offset\nGet the file size\nSync all pending data to storage\nWrite data to file at specific offset, ensuring all bytes ‚Ä¶\nWrite data to the file at a specific offset\nUnified metadata interface for both local and remote ‚Ä¶\nGet last access time\nGet device ID\nGet file type as a string\nGet a human-readable description of the file type\nGet group ID of the file owner\nGet inode number\nCheck if this is a directory\nCheck if the file or directory is empty\nCheck if this is a regular file\nCheck if this metadata represents the same file as another ‚Ä¶\nCheck if this is a special file (device, socket, pipe, ‚Ä¶\nCheck if this is a symlink\nGet link count\nGet last modification time\nGet file permissions\nGet the size of the file or directory\nGet a summary of the metadata\nGet user ID of the file owner")